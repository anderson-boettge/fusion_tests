/**Accelerator class MatrixAccel*/
public accelerator class MatrixAccel 
{
	private int rowsA;
	private int rowsB;
	private int colsB;
	private int colsA;
	private int nRows;

	private device int matrixB_d [];
	private device int matrixA_d [];
	private device int matrixC_d [];
	
	MatrixAccel(int nRows){
		this.nRows = nRows;
	}
	/*receiving two arrays performs the allocation both and 
	copy of matrixB to the device*/
	public void setMatrix(int matrixA_h [][], int matrixB_h [][])
        {
		matrixC_h = new int [rowsA][colsB];
		rowsA = matrixA_h.length;
		colsA = matrixA_h[0].length;
		rowsB = matrixB_h.length;
		colsB = matrixB_h[0].length;
		
		matrixA_d = new int [rowsA*colsA];
		matrixB_d = new int [rowsB*colsB];
		matrixC_d = new int [rowsA*colsB];
		
		memCpy(matrixB_d, matrixB_h, rowsB*colsB, hostTodevice);
	}
	
	/**Parallel unit responsable for partial solution*/
	parallel unit Multiply 
	{
		
                Multiply()
		{
		   rank = getRank();
		   memCpyAsync(matrixA_d, colsA*rank, matrixA_h, colsA*rank, colsA,rank);
		}

		public parallel kernel multiplyBlockLine() grid<(nRows,colsB), (1)>
                {
			int idx = threadIdx(x);
			int idy = threadIdx(y);
			int aBegin = rank*nRows*colsA;
			int cBegin = rank*nRows*colsB;
			int i, j;
			shared int As [nRows*colsA];
			int subC = 0;
			if (idx+idy==0){
				for(i=0,j=aBegin ; i<nRows*colsA; j++ , i++)
					As[i] = matrixA_d[j];
			}
			synchronized(threads);
			for(i=0; i<colsA; i++){
				subC += As[colsA*idy+i] * matrixB_d[i*colsB+idx];
			}
			matrixC_d[cBegin+idy*colsB+idx] = subC;
		}

		public parallel int [][] getResult(){
			memCpyA(matrixC_h, colsB*nRows*rank, 
					matrixC_d, colsB*nRows*rank, 
					colsB*nRows, rank);
			synchronized(device);
			return matrixC_h;

		}
	}
}
